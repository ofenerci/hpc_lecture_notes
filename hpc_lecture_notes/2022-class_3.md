# Class 3 (Monday 24 October)

These tasks are designed to be worked on in the practical class on Monday 24 October.

In this class, we'll be running code on a GPU using Cuda. If you don't have a suitable device on your own computer, you should
use Google Colab this week: you can use a GPU in Colab by selecting Runtime -> Change Runtime Type and selecting a GPU. To see if you have a device available, you can run:

```python
from numba import cuda
cuda.detect()
```

During this class, you may wish to use the [GPU accelerated evaluation of particle sums](rbf_evaluation.md) section of the lecture notes, where a
similar example is worked through using a radial basis function kernel.

## Background
In lots of applications, it is useful to calculate the sum
$$\sum_jc_jg(\mathbf{x}, \mathbf{y}_j),$$
where $g$ is a "kernel" function, $\mathbf{x}$ is a point in $\mathbb{R}^3$,
$\mathbf{y}_0,...,\mathbf{y}_{n-1}$ are (known) points in $\mathbb{R}^3$, and
$c_0,...,c_{n-1}$ are (known) values in $\mathbb{C}$.

In this class, we're going to use the acoustic Green's function
$$g(\mathbf{x},\mathbf{y})=\mathrm{e}^{-\mathrm{i}k\left|\mathbf{x}-\mathbf{y}\right|}/{4\mathrm{\pi}\left|\mathbf{x}-\mathbf{y}\right|},$$
where $k$ is the wavenumber of the wave.
This is the acoustic wave due to a point source: if there are point sources at points $\mathbf{y}_0,...,\mathbf{y}_{n-1}$ of sizes
$c_0,...,c_{n-1}$, then the sum above can be used to compute the magnitude of a (time-harmonic) acoustic wave at each point.

## Plotting some waves
There is a point source with wavenumber 10 at the point $(-1.2, 0, 0)$ with magnitude 1.
The following code plots a slice through the wave due to this source in the plane $z=0$ with $0\leqslant x\leqslant 3$ and $-\frac32\leqslant y\leqslant \frac32$.

```python
import numpy as np
import matplotlib.pylab as plt

k = 10.


def g(x, y):
    """Evaluate the acoustic Green's function."""
    return np.exp(1j * k * np.linalg.norm(x - y)) / 4 / np.pi / np.linalg.norm(x - y)


sources = np.array([[-1.2, 0., 0.]])
magnitudes = np.array([1.0])

img_size = 250
values = np.empty((img_size, img_size), dtype="complex128")

xmin = 0
xmax = 3
ymin = -1.5
ymax = 1.5

# plt.imshow interprets data as the colour of pixels starting at the top left then 
# row by row. For example, if an image was 5 pixels wide, the order of the pixels
# would be:
# 0 1 2 3 4
# 5 6 7 8 9
# etc
# Due to this ordering, the y values here might at first glance appear to be backwards
for i in range(img_size):
    y = ymax + (ymin - ymax) * i / (img_size - 1)
    for j in range(img_size):
        x = xmin + (xmax - xmin) * j / (img_size - 1)
        point = np.array([x, y, 0])
        v = 0
        for m, s in zip(magnitudes, sources):
            v += m * g(s, point)
        values[i, j] = v     

plt.imshow(np.real(values), extent=[xmin, xmax, ymin, ymax])
plt.show()
```
